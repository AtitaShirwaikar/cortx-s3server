diff --git a/evhtp.c b/evhtp.c
index a97c836..497f179 100644
--- a/evhtp.c
+++ b/evhtp.c
@@ -69,6 +69,7 @@ static evhtp_path_t       * _evhtp_path_new(const char * data, size_t len);
 static void                 _evhtp_path_free(evhtp_path_t * path);
 
 static void                 _evhtp_request_free(evhtp_request_t *);
+size_t g_buffer_size;  /* S3 edit */
 
 #define HOOK_AVAIL(var, hook_name)                 (var->hooks && var->hooks->hook_name)
 #define HOOK_FUNC(var, hook_name)                  (var->hooks->hook_name)
@@ -1794,7 +1795,6 @@ _evhtp_connection_readcb(evbev_t * bev, void * arg) {
     if (c->paused == 1) {
         return;
     }
-
     buf   = evbuffer_pullup(bufferevent_get_input(bev), avail);
 
     htp_log_debug("buffer is\n----\n%.*s\n-----", (int)avail, (const char *)buf);
@@ -1828,10 +1828,51 @@ _evhtp_connection_readcb(evbev_t * bev, void * arg) {
 
     evbuffer_drain(bufferevent_get_input(bev), nread);
 
+    /* S3 edit starts */
+    if (htparser_body_was_deferred(c->parser)
+      && ((avail - nread) == htparser_get_content_pending(c->parser))) {
+        // We have all the data, align the buffer and complete parsing
+        buf   = evbuffer_pullup(bufferevent_get_input(bev), avail - nread);
+        nread = htparser_run(c->parser, &request_psets,
+                             (const char *)buf, avail - nread);
+        evbuffer_drain(bufferevent_get_input(bev), nread);
+        htp_log_debug("nread after parser rerun = %zu", nread);
+    }
+    if (htparser_get_content_pending(c->parser) < g_buffer_size) {
+      /* If data remaining is less than the buffer size then set low water mark
+         to that value, mostly last part of body */
+      bufferevent_setwatermark(bev, EV_READ,
+                               htparser_get_content_pending(c->parser),
+                               g_buffer_size);
+      htp_log_debug("Reset lowwatermark(%zu) and highwatermark(%zu).\n",
+                     htparser_get_content_pending(c->parser), g_buffer_size);
+    }
+    /* S3 edit ends */
+
     if (c->request && c->request->status == EVHTP_RES_PAUSE) {
         evhtp_request_pause(c->request);
     } else if (htparser_get_error(c->parser) != htparse_error_none) {
         evhtp_connection_free(c);
+    } else if (htparser_body_was_deferred(c->parser)) {
+      /* S3 edit starts */
+      /* This is to ensure that we have maximum data in buffer */
+      /* Next bufferevent read will try to read nread more data to buffer
+      */
+      htp_log_debug("Ask for more nread(%zu) data (= header size).\n", nread);
+      bufferevent_set_read_data(bev, nread);
+
+      if (htparser_get_content_pending(c->parser) >= g_buffer_size) {
+        htp_log_debug("Set lowwatermark(%zu) and highwatermark(%zu).\n",
+                      g_buffer_size, g_buffer_size);
+        bufferevent_setwatermark(bev, EV_READ, g_buffer_size, g_buffer_size);
+      } else {
+        htp_log_debug("Set lowwatermark(%zu) and highwatermark(%zu).\n",
+                      htparser_get_content_pending(c->parser), g_buffer_size);
+        bufferevent_setwatermark(bev, EV_READ,
+                                 htparser_get_content_pending(c->parser),
+                                 g_buffer_size);
+      }
+      /* S3 edit ends */
     } else if (nread < avail) {
         /* we still have more data to read (piped request probably) */
         evhtp_connection_resume(c);
@@ -3255,6 +3296,11 @@ evhtp_bind_sockaddr(evhtp_t * htp, struct sockaddr * sa, size_t sin_len, int bac
 
     setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&on, sizeof(on));
     setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof(on));
+#if defined SO_REUSEPORT
+    if (htp->enable_reuseport) {
+        setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, (void *)&on, sizeof(on));
+    }
+#endif
 
     if (sa->sa_family == AF_INET6) {
         int rc;
@@ -4439,3 +4485,9 @@ evhtp_request_status(evhtp_request_t * r) {
     return htparser_get_status(r->conn->parser);
 }
 
+/* S3 edit starts */
+void
+evhtp_set_low_watermark(size_t buffer_size) {
+    g_buffer_size = buffer_size;
+}
+/* S3 edit starts */
diff --git a/evhtp.h b/evhtp.h
index a67badb..a469633 100644
--- a/evhtp.h
+++ b/evhtp.h
@@ -1380,6 +1380,13 @@ EVHTP_EXPORT int evhtp_make_request(evhtp_connection_t * c,
 
 EVHTP_EXPORT unsigned int evhtp_request_status(evhtp_request_t *);
 
+/* S3 edit starts */
+/**
+ * @brief set low water mark
+ */
+EVHTP_EXPORT void evhtp_set_low_watermark(size_t buffer_size);
+/* S3 edit ends */
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/htparse.c b/htparse.c
index d4bcf3e..6460b7d 100644
--- a/htparse.c
+++ b/htparse.c
@@ -10,7 +10,9 @@
 
 #include "htparse.h"
 #include "evhtp-internal.h"
+#include <event2/bufferevent.h>
 
+// #define PARSER_DEBUG
 #ifdef PARSER_DEBUG
 #define __QUOTE(x)                  # x
 #define  _QUOTE(x)                  __QUOTE(x)
@@ -39,6 +41,10 @@
 #define CR               (unsigned char)13
 #define CRLF             "\x0d\x0a"
 
+/* S3 edit starts */
+extern size_t g_buffer_size;
+/* S3 edit ends */
+
 enum eval_hdr_val {
     eval_hdr_val_none = 0,
     eval_hdr_val_connection,
@@ -54,6 +60,7 @@ enum parser_flags {
     parser_flag_connection_keep_alive = (1 << 1),
     parser_flag_connection_close      = (1 << 2),
     parser_flag_trailing              = (1 << 3),
+    parser_defer_body                  = (1<< 4), /* S3 edit */
 };
 
 enum parser_state {
@@ -385,6 +392,13 @@ htparser_get_status(htparser * p) {
     return p->status;
 }
 
+/* S3 edit starts */
+unsigned int
+htparser_body_was_deferred(htparser * p) {
+   return p->flags & parser_defer_body;
+}
+/* S3 edit ends */
+
 int
 htparser_should_keep_alive(htparser * p) {
     if (p->major > 0 && p->minor > 0) {
@@ -1832,6 +1846,14 @@ hdrline_start:
                             p->state = s_chunk_size_start;
                         } else if (p->content_len > 0) {
                             p->state = s_body_read;
+                            /* S3 edit starts */
+                            if (p->method == htp_method_PUT) {
+                               /* preempt reading data, this is force
+                               data buffer alignment for caller of htparser_run */
+                               p->flags  |= parser_defer_body;
+                               return i + 1;
+                            }
+                            /* S3 edit ends */
                         } else if (p->content_len == 0) {
                             res      = hook_on_msg_complete_run(p, hooks);
                             p->state = s_start;
@@ -1870,6 +1892,12 @@ hdrline_start:
                 } else if (p->content_len > 0) {
                     p->state = s_body_read;
                     i--;
+                    /* S3 edit starts */
+                    if (p->method == htp_method_PUT) {
+                       p->flags  |= parser_defer_body;
+                       return i;
+                    }
+                    /* S3 edit ends */
                 } else if (p->content_len == 0) {
                     res      = hook_on_msg_complete_run(p, hooks);
                     p->state = s_start;
@@ -1992,6 +2020,10 @@ hdrline_start:
                 res = 0;
 
                 {
+                    /* S3 edit starts */
+                    p->flags &= ~parser_defer_body;
+                    /* S3 edit ends */
+
                     const char * pp      = &data[i];
                     const char * pe      = (const char *)(data + len);
                     size_t       to_read = _MIN_READ(pe - pp, p->content_len);
@@ -2032,4 +2064,3 @@ hdrline_start:
 
     return i;
 }         /* htparser_run */
-
diff --git a/htparse.h b/htparse.h
index da2fd53..f869805 100644
--- a/htparse.h
+++ b/htparse.h
@@ -106,6 +106,9 @@ EVHTP_EXPORT unsigned char  htparser_get_major(htparser *);
 EVHTP_EXPORT unsigned char  htparser_get_minor(htparser *);
 EVHTP_EXPORT unsigned char  htparser_get_multipart(htparser *);
 EVHTP_EXPORT unsigned int   htparser_get_status(htparser *);
+/* S3 edit starts */
+EVHTP_EXPORT unsigned int   htparser_body_was_deferred(htparser *);
+/* S3 edit ends */
 EVHTP_EXPORT uint64_t       htparser_get_content_length(htparser *);
 EVHTP_EXPORT uint64_t       htparser_get_content_pending(htparser *);
 EVHTP_EXPORT uint64_t       htparser_get_total_bytes_read(htparser *);
@@ -121,4 +124,3 @@ EVHTP_EXPORT htparser     * htparser_new(void);
 #endif
 
 #endif
-
