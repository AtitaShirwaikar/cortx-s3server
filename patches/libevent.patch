diff --git a/Makefile.am b/Makefile.am
index 75e376d..43e761b 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -173,7 +173,7 @@ include/event2/event-config.h: config.h make-event-config.sed
 	$(SED) -f $(srcdir)/make-event-config.sed < config.h > $@T
 	mv -f $@T $@

-CORE_SRC = event.c evthread.c buffer.c \
+CORE_SRC = event.c ../../mempool/s3_memory_pool.c evthread.c buffer.c \
 	bufferevent.c bufferevent_sock.c bufferevent_filter.c \
 	bufferevent_pair.c listener.c bufferevent_ratelim.c \
 	evmap.c	log.c evutil.c evutil_rand.c strlcpy.c $(SYS_SRC)
@@ -213,7 +213,7 @@ libevent_openssl_la_LIBADD = $(MAYBE_CORE) $(OPENSSL_LIBS)
 libevent_openssl_la_LDFLAGS = $(GENERIC_LDFLAGS)
 endif

-noinst_HEADERS = util-internal.h mm-internal.h ipv6-internal.h \
+noinst_HEADERS = util-internal.h ../../mempool/s3_memory_pool.h mm-internal.h ipv6-internal.h \
 	evrpc-internal.h strlcpy-internal.h evbuffer-internal.h \
 	bufferevent-internal.h http-internal.h event-internal.h \
 	evthread-internal.h ht-internal.h defer-internal.h \
@@ -232,7 +232,7 @@ else
 noinst_HEADERS += $(EVENT1_HDRS)
 endif

-AM_CPPFLAGS = -I$(srcdir)/compat -I$(srcdir)/include -I./include $(SYS_INCLUDES)
+AM_CPPFLAGS = -I$(srcdir)/compat -I$(srcdir)/include -I./include -I../../mempool $(SYS_INCLUDES)

 verify: check

diff --git a/buffer.c b/buffer.c
index 8510955..c1b5f32 100644
--- a/buffer.c
+++ b/buffer.c
@@ -118,7 +118,6 @@ static int use_sendfile = 1;
 static int use_mmap = 1;
 #endif

-
 /* Mask of user-selectable callback flags. */
 #define EVBUFFER_CB_USER_FLAGS	    0xffff
 /* Mask of all internal-use-only flags. */
@@ -156,11 +155,11 @@ evbuffer_chain_new(size_t size)
 {
 	struct evbuffer_chain *chain;
 	size_t to_alloc;
+	size_t pool_item_size = 0;

-	if (size > EVBUFFER_CHAIN_MAX - EVBUFFER_CHAIN_SIZE)
+	if (size > EVBUFFER_CHAIN_MAX)
 		return (NULL);

-	size += EVBUFFER_CHAIN_SIZE;

 	/* get the next largest memory that can hold the buffer */
 	if (size < EVBUFFER_CHAIN_MAX / 2) {
@@ -172,18 +171,30 @@ evbuffer_chain_new(size_t size)
 		to_alloc = size;
 	}

-	/* we get everything in one chunk */
-	if ((chain = mm_malloc(to_alloc)) == NULL)
+	/* Allocating the structure, buffer within this structure will be
+	 * allocated separately */
+	if ((chain = mm_malloc(EVBUFFER_CHAIN_SIZE)) == NULL)
 		return (NULL);

-	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
-
-	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
+	mempool_getbuffer_size(g_pool_handle, &pool_item_size);

-	/* this way we can manipulate the buffer to different addresses,
-	 * which is required for mmap for example.
-	 */
-	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
+	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
+	if (pool_item_size == to_alloc) {
+		if ((chain->buffer = (unsigned char *)mempool_getbuffer(
+			g_pool_handle, ZEROED_ALLOCATION)) == NULL) {
+			mm_free(chain);
+			return NULL;
+		}
+	} else {
+		if ((chain->buffer = (unsigned char *)mm_malloc(to_alloc)) ==
+		    NULL) {
+			mm_free(chain);
+			return NULL;
+		}
+	}
+	chain->buffer_len = to_alloc;
+	chain->chain_buffer = chain->buffer;
+	chain->chain_buffer_len = to_alloc;

 	return (chain);
 }
@@ -191,6 +202,7 @@ evbuffer_chain_new(size_t size)
 static inline void
 evbuffer_chain_free(struct evbuffer_chain *chain)
 {
+	size_t pool_item_size = 0;
 	if (CHAIN_PINNED(chain)) {
 		chain->flags |= EVBUFFER_DANGLING;
 		return;
@@ -231,6 +243,15 @@ evbuffer_chain_free(struct evbuffer_chain *chain)
 #endif
 	}

+	mempool_getbuffer_size(g_pool_handle, &pool_item_size);
+
+	if (chain->chain_buffer_len == pool_item_size) {
+		/* If the buffer size is same as that of pool's buffer size then
+		 * this have been allocated from pool, so release to pool */
+		mempool_releasebuffer(g_pool_handle, chain->chain_buffer);
+	} else {
+		mm_free(chain->chain_buffer);
+	}
 	mm_free(chain);
 }

@@ -961,7 +982,6 @@ evbuffer_drain(struct evbuffer *buf, size_t len)
 	struct evbuffer_chain *chain, *next;
 	size_t remaining, old_len;
 	int result = 0;
-
 	EVBUFFER_LOCK(buf);
 	old_len = buf->total_len;

@@ -2762,6 +2782,7 @@ evbuffer_add_reference(struct evbuffer *outbuf,
 		/* don't call chain_free; we do not want to actually invoke
 		 * the cleanup function */
 		mm_free(chain);
+		mm_free(info);
 		goto done;
 	}
 	evbuffer_chain_insert(outbuf, chain);
@@ -2827,6 +2848,7 @@ evbuffer_add_file(struct evbuffer *outbuf, int fd,
 		EVBUFFER_LOCK(outbuf);
 		if (outbuf->freeze_end) {
 			mm_free(chain);
+			mm_free(info);
 			ok = 0;
 		} else {
 			outbuf->n_add_for_cb += length;
diff --git a/evbuffer-internal.h b/evbuffer-internal.h
index f9dcc06..c105fcc 100644
--- a/evbuffer-internal.h
+++ b/evbuffer-internal.h
@@ -52,7 +52,7 @@ extern "C" {
 #if _EVENT_SIZEOF_VOID_P < 8
 #define MIN_BUFFER_SIZE	512
 #else
-#define MIN_BUFFER_SIZE	1024
+#define MIN_BUFFER_SIZE	4096
 #endif

 /** A single evbuffer callback for an evbuffer. This function will be invoked
@@ -173,6 +173,9 @@ struct evbuffer_chain {
 	/** total allocation available in the buffer field. */
 	size_t buffer_len;

+	/** Total allocation created initially */
+	size_t chain_buffer_len;
+
 	/** unused space at the beginning of buffer or an offset into a
 	 * file for sendfile buffers. */
 	ev_misalign_t misalign;
@@ -204,6 +207,9 @@ struct evbuffer_chain {
 	 * may point to NULL.
 	 */
 	unsigned char *buffer;
+	/* Will hold the initial address of buffer, will be used to free the
+	 * same */
+	unsigned char *chain_buffer;
 };

 /* this is currently used by both mmap and sendfile */
@@ -223,7 +229,8 @@ struct evbuffer_chain_reference {

 #define EVBUFFER_CHAIN_SIZE sizeof(struct evbuffer_chain)
 /** Return a pointer to extra data allocated along with an evbuffer. */
-#define EVBUFFER_CHAIN_EXTRA(t, c) (t *)((struct evbuffer_chain *)(c) + 1)
+#define EVBUFFER_CHAIN_EXTRA(t, c)                                             \
+	(t *)(((struct evbuffer_chain *)(c))->chain_buffer)

 /** Assert that we are holding the lock on an evbuffer */
 #define ASSERT_EVBUFFER_LOCKED(buffer)			\
diff --git a/event.c b/event.c
index fab419a..3e3ad84 100644
--- a/event.c
+++ b/event.c
@@ -25,6 +25,7 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "event2/event-config.h"
+#include "s3_memory_pool.h"

 #ifdef WIN32
 #include <winsock2.h>
@@ -125,6 +126,9 @@ struct event_base *event_global_current_base_ = NULL;

 static int use_monotonic;

+/* global Memory Pool handle */
+MemoryPoolHandle g_pool_handle;
+
 /* Prototypes */
 static inline int event_add_internal(struct event *ev,
     const struct timeval *tv, int tv_is_absolute);
@@ -2726,6 +2730,21 @@ event_set_mem_functions(void *(*malloc_fn)(size_t sz),
 	_mm_free_fn = free_fn;
 }
 #endif
+int
+evthread_use_mempool(size_t item_size, size_t pool_initial_size,
+		     size_t pool_expansion_size,
+		     size_t pool_max_threshold_size,
+		     int flags)
+{
+	int rc;
+	rc = mempool_create(item_size, pool_initial_size, pool_expansion_size,
+			pool_max_threshold_size, flags, &g_pool_handle);
+	if (rc != 0)
+		return rc;
+
+	return 0;
+}
+

 #if defined(_EVENT_HAVE_EVENTFD) && defined(_EVENT_HAVE_SYS_EVENTFD_H)
 static void
diff --git a/include/event2/event.h b/include/event2/event.h
index 10bcd97..79a9136 100644
--- a/include/event2/event.h
+++ b/include/event2/event.h
@@ -295,6 +295,24 @@ struct event_config
 ;

 /**
+ * Enable use of memory pool for libevent.
+ * Memory pool is created with some pre allocated buffers of fixed size.
+ * Memory will be allocated/released from/to the buffer pool for the libevent
+ * buffers.
+ *
+ * @param item_size the buffer size in the pool
+ * @param pool_initial_size the pool's initial preallocated memory
+ * @param pool_expansion_size the pool's memory expansion size
+ * @param pool_max_threshold_size Maximum outstanding memory that can be alloted
+ * from pool
+ * @flags CREATE_ALIGNED_MEMORY, ENABLE_LOCKING
+ * @return 0 if successful otherwise an error
+ */
+int evthread_use_mempool(size_t item_size, size_t pool_initial_size,
+			 size_t pool_expansion_size,
+			 size_t pool_max_threshold_size, int flags);
+
+/**
  * Enable some relatively expensive debugging checks in Libevent that
  * would normally be turned off.  Generally, these checks cause code that
  * would otherwise crash mysteriously to fail earlier with an assertion
diff --git a/mm-internal.h b/mm-internal.h
index b375155..be78cfd 100644
--- a/mm-internal.h
+++ b/mm-internal.h
@@ -27,6 +27,7 @@
 #define _EVENT_MM_INTERNAL_H

 #include <sys/types.h>
+#include "s3_memory_pool.h"

 #ifdef __cplusplus
 extern "C" {
@@ -54,6 +55,9 @@ void event_mm_free_(void *p);
 #define mm_free(p) free(p)
 #endif

+/* Memory Pool handle declaration */
+extern MemoryPoolHandle g_pool_handle;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/test/Makefile.am b/test/Makefile.am
index 0253a49..d55aea4 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -6,7 +6,7 @@

 AUTOMAKE_OPTIONS = foreign

-AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)/compat -I$(top_srcdir)/include -I../include -DTINYTEST_LOCAL
+AM_CPPFLAGS = -I$(top_srcdir) -I$(top_srcdir)/compat -I$(top_srcdir)/include -I../include -I ../../../mempool -DTINYTEST_LOCAL

 EXTRA_DIST = regress.rpc regress.gen.h regress.gen.c rpcgen_wrapper.sh test.sh

